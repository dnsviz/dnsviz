#!/usr/bin/env python
#
# This file is a part of DNSViz, a tool suite for DNS/DNSSEC monitoring,
# analysis, and visualization.
# Created by Casey Deccio (casey@deccio.net)
#
# Copyright 2014-2015 VeriSign, Inc.
#
# DNSViz is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# DNSViz is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

import codecs
import collections
import getopt
import json
import logging
import re
import sys

import dns.exception, dns.message, dns.name

from dnsviz.analysis import OfflineDomainNameAnalysis, DNS_RAW_VERSION, DNS_PROCESSED_VERSION
from dnsviz.util import get_trusted_keys

# we permit dnsgrok to run without having pygraphviz installed because it is
# not used unless -t is specified.  If -t is used on the command line, then we
# check for the existence of pygraphviz.
try:
    from dnsviz.viz.dnssec import DNSAuthGraph
except ImportError:
    pass

logger = logging.getLogger('dnsviz.analysis.offline')

DNS_RAW_VERSION = 1.0

def usage(err=None):
    if err is not None:
        err += '\n\n'
    else:
        err = ''
    sys.stderr.write('''%sUsage: %s [ options ] [ -f <filename> | <domain name> [... ] ]
Options:
    -f <filename>  - read names from a file (one name per line), instead of
                     from command line.
    -r <filename>  - read analysis from a file, instead of from stdin.
    -t <filename>  - use filename as a file containing trusted keys, each as
                     a DNSKEY RR, in zone file format.
    -o <filename>  - save the output to filename instead of to stdout.
    -p             - make json output pretty instead of minimal.
    -l <loglevel>  - set log level to one of: error, warning, info, debug.
    -h             - display the usage and exit.
''' % (err, sys.argv[0]))

def test_m2crypto():
    try:
        import M2Crypto
    except ImportError:
        sys.stderr.write('''Warning: M2Crypto is not installed; cryptographic validation of signatures and digests will not be available.\n''')

def test_pygraphviz():
    try:
        from pygraphviz import release
        try:
            major, minor = release.version.split('.')[:2]
            major = int(major)
            minor = int(re.sub(r'(\d+)[^\d].*', r'\1', minor))
            if (major, minor) < (1,1):
                sys.stderr.write('''pygraphviz version >= 1.1 is required, but version %s is installed.\n''' % release.version)
                sys.exit(3)
        except ValueError:
            sys.stderr.write('''pygraphviz version >= 1.1 is required, but version %s is installed.\n''' % release.version)
            sys.exit(3)
    except ImportError:
        sys.stderr.write('''pygraphviz is required, but not installed.\n''')
        sys.exit(3)

def main():
    try:
        test_m2crypto()

        try:
            opts, args = getopt.getopt(sys.argv[1:], 'f:r:t:o:pl:h')
        except getopt.GetoptError, e:
            usage(str(e))
            sys.exit(1)

        opts = dict(opts)
        if '-h' in opts:
            usage()
            sys.exit(0)

        if not ('-f' in opts or args) and '-r' not in opts:
            usage('When -r is not used, either -f must be used or domain names must be supplied as command line arguments.')
            sys.exit(1)
        if '-f' in opts and args:
            usage('If -f is used, then domain names may not supplied as command line arguments.')
            sys.exit(1)

        if '-l' in opts:
            if opts['-l'] == 'error':
                loglevel = logging.ERROR
            elif opts['-l'] == 'warning':
                loglevel = logging.WARNING
            elif opts['-l'] == 'info':
                loglevel = logging.INFO
            elif opts['-l'] == 'debug':
                loglevel = logging.DEBUG
            else:
                usage('Invalid log level: "%s"' % opts['-l'])
                sys.exit(1)
        else:
            loglevel = logging.DEBUG
        handler = logging.StreamHandler()
        handler.setLevel(logging.WARNING)
        logger.addHandler(handler)
        logger.setLevel(logging.WARNING)

        if '-r' not in opts or opts['-r'] == '-':
            analysis_str = sys.stdin.read()
        else:
            try:
                analysis_str = open(opts['-r']).read()
            except IOError, e:
                logger.error('%s: "%s"' % (e.strerror, opts['-r']))
                sys.exit(2)
        try:
            analysis_structured = json.loads(analysis_str)
        except ValueError:
            logger.error('There was an error parsing the json input: "%s"' % opts.get('-r', '-'))
            sys.exit(2)

        # check version
        if '_meta._dnsviz.' in analysis_structured and 'version' in analysis_structured['_meta._dnsviz.'] and analysis_structured['_meta._dnsviz.']['version'] > DNS_RAW_VERSION:
            logger.error('Unsupported version: "%s"' % analysis_structured['_meta._dnsviz.']['version'])
            sys.exit(2)

        names = []
        if '-f' in opts:
            try:
                f = codecs.open(opts['-f'], 'r', 'utf-8')
            except IOError, e:
                logger.error('%s: "%s"' % (e.strerror, opts['-f']))
                sys.exit(2)
            for line in f:
                name = line.strip()
                try:
                    name = dns.name.from_unicode(name)
                except UnicodeDecodeError, e:
                    logger.error('%s: "%s"' % (e, name))
                except dns.exception.DNSException:
                    logger.error('The domain name was invalid: "%s"' % name)
                else:
                    names.append(name)
            f.close()
        else:
            if not args:
                try:
                    args = analysis_structured['_meta._dnsviz.']['names']
                except KeyError:
                    logger.error('No names found in json input!')
                    sys.exit(2)
            for name in args:
                try:
                    name = dns.name.from_text(name)
                except dns.exception.DNSException:
                    logger.error('The domain name was invalid: "%s"' % name)
                else:
                    names.append(name)

        if '-p' in opts:
            kwargs = { 'indent': 4, 'separators': (',', ': ') }
        else:
            kwargs = {}

        if '-o' not in opts or opts['-o'] == '-':
            fh = sys.stdout
        else:
            try:
                fh = open(opts['-o'], 'w')
            except IOError, e:
                logger.error('%s: "%s"' % (e.strerror, opts['-o']))
                sys.exit(2)

        if '-t' in opts:
            try:
                tk_str = open(opts['-t']).read()
            except IOError, e:
                logger.error('%s: "%s"' % (e.strerror, opts['-t']))
                sys.exit(2)
            try:
                trusted_keys = get_trusted_keys(tk_str)
            except dns.exception.DNSException:
                logger.error('There was an error parsing the trusted keys file: "%s"' % opts['-t'])
                sys.exit(2)
            # check that pygraphviz is installed
            test_pygraphviz()
        else:
            trusted_keys = ()

        name_objs = []
        for name in names:
            name_str = name.canonicalize().to_text()
            if name_str not in analysis_structured or analysis_structured[name_str].get('stub', True):
                logger.error('The analysis of "%s" was not found in the input.' % name.to_text())
                continue
            name_objs.append(OfflineDomainNameAnalysis.deserialize(name, analysis_structured))

        if not name_objs:
            sys.exit(2)

        d = collections.OrderedDict()
        for name_obj in name_objs:
            name_obj.populate_status(trusted_keys)

            if trusted_keys:
                G = DNSAuthGraph()
                for qname, rdtype in name_obj.queries:
                    if rdtype in (dns.rdatatype.NS, dns.rdatatype.DNSKEY, dns.rdatatype.DS, dns.rdatatype.DLV):
                        continue
                    G.graph_rrset_auth(name_obj, qname, rdtype)
                G.add_trust(trusted_keys)
                name_obj.populate_response_component_status(G)

            name_obj.serialize_status(d, loglevel=loglevel)

        if d:
            fh.write(json.dumps(d, **kwargs))

    except KeyboardInterrupt:
        logger.error('Interrupted.')
        sys.exit(4)

if __name__ == "__main__":
    main()
